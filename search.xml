<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git 笔记</title>
    <url>/EchoNotes/2020/07/20/GitNotes/</url>
    <content><![CDATA[<p>Git是版本管理工具，功能很强大</p>
<a id="more"></a>
<h4 id="GitHub-Pages部署Vue静态页面"><a href="#GitHub-Pages部署Vue静态页面" class="headerlink" title="GitHub Pages部署Vue静态页面"></a>GitHub Pages部署Vue静态页面</h4><ul>
<li>将dist目录下的所有文件夹推送至远程仓库的gh-pages分支<ul>
<li>强制添加dist文件夹<br><code>git add -f dist</code></li>
<li>提交到本地暂存区<br><code>git commit -m &#39;注释...&#39;</code></li>
<li>dist目录下的代码推送到远程仓库<br><code>git subtree push --prefix dist origin gh-pages</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记</title>
    <url>/EchoNotes/2020/08/17/JavaNotes/</url>
    <content><![CDATA[<h2 id="Java学习笔记"><a href="#Java学习笔记" class="headerlink" title="Java学习笔记"></a>Java学习笔记</h2><a id="more"></a>
<h3 id="栈区存引用和基本类型，而堆区存对象"><a href="#栈区存引用和基本类型，而堆区存对象" class="headerlink" title="栈区存引用和基本类型，而堆区存对象"></a>栈区存引用和基本类型，而堆区存对象</h3><h3 id="把线程不安全变成线程安全："><a href="#把线程不安全变成线程安全：" class="headerlink" title="把线程不安全变成线程安全："></a>把线程不安全变成线程安全：</h3><p>可以用Collections里的synchronizedXxx方法</p>
<ol>
<li>通过synchronizedList方法，我们能把一个List（比如ArrayList或LinkedList）包装成线程安全的，代码如下：<br><code>Collections.synchronizedList(stuList);</code></li>
<li>通过synchronizedSet方法，能把一个Set对象包装成线程安全的，代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set set &#x3D; new HashSet();</span><br><span class="line">Collections.synchronizedSet(set);</span><br></pre></td></tr></table></figure></li>
<li>通过synchronizedMap方法，能把一个Map对象包装成线程安全的，代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap hm &#x3D; new HashMap();</span><br><span class="line">Collections.synchronizedMap(hm);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="从线程内存结构中了解并发结果不一致的原因"><a href="#从线程内存结构中了解并发结果不一致的原因" class="headerlink" title="从线程内存结构中了解并发结果不一致的原因"></a>从线程内存结构中了解并发结果不一致的原因</h3><p>  多线程并发操作同一资源时，可能会出现最终结果和预期不同的情况。<br>  如果某个线程要操作data变量，该线程会先把data变量装载到线程内部的内存中做个副本，之后线程就不再和在主内存中的data变量有任何关系，而是会操作副本变量的值，操作完成后，再把这个副本回写到主内存（也就是堆内存）中。</p>
<p>  <img src="https://s1.ax1x.com/2020/08/19/dlphqS.png" alt="线程操作某变量的示意图" title="线程操作某变量的示意图"></p>
<p>  但如果我们通过锁（或Condition或Semaphore）来管理data变量，那么可以保证在同一个时间段里只有1个线程能操作该变量，所以也就能避免数据不一致的问题。</p>
<h3 id="volatile不能解决数据不一致的问题"><a href="#volatile不能解决数据不一致的问题" class="headerlink" title="volatile不能解决数据不一致的问题"></a>volatile不能解决数据不一致的问题</h3><ul>
<li>如果某个变量之前加了volatile，线程在每次使用该变量时，都会从主内存中读取该变量最新的值，而且，某线程一旦修改了该变量，这个修改会立即回写到主内存里。</li>
<li>用volatile修饰的变量不能保证数据一致性，换句话说，volatile不能当锁来用，因为它不能保证主内存的变量在同一时间段里只被一个线程操作。</li>
<li>那么volatile有什么用呢？被volatile修饰的变量每次在使用时，不是从各线程的内部内存中拿，而是从主内存中拿。这样就能避免“创建副本”到“把副本回写到主内存中”等的操作，从而能提升效率。</li>
<li>但请注意，如果我们在多线程环境下，针对某个变量有读和写的操作，那么别把它修饰成volatile，因为为了解决数据不一致的问题，我们会给该变量加锁，这样该变量在一个时间段里只会有一个线程进行操作，这样就无法发挥出volatile的优势了。</li>
<li>请记住这个结论，如果某个变量在多线程环境下只有读或者是只有写的操作，建议把它设置成volatile，这样能提升多线程并发时的效率。<br>

</li>
</ul>
<h3 id="Java跨平台的特性"><a href="#Java跨平台的特性" class="headerlink" title="Java跨平台的特性"></a>Java跨平台的特性</h3><p><img src="https://s1.ax1x.com/2020/08/19/dlN15F.png" alt="java代码、字节码、虚拟机和操作系统之间的关系" title="java代码、字节码、虚拟机和操作系统之间的关系"><br><br></p>
<h3 id="虚拟机体系结构"><a href="#虚拟机体系结构" class="headerlink" title="虚拟机体系结构"></a>虚拟机体系结构</h3><p><img src="https://s1.ax1x.com/2020/08/19/dlwjX9.png" alt="虚拟机体系结构" title="虚拟机体系结构"><br><br></p>
<h3 id="各种类型数据在虚拟机里的存储位置"><a href="#各种类型数据在虚拟机里的存储位置" class="headerlink" title="各种类型数据在虚拟机里的存储位置"></a>各种类型数据在虚拟机里的存储位置</h3><table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
<th>存储位置</th>
</tr>
</thead>
<tbody><tr>
<td>静态变量</td>
<td>static int val = 1;</td>
<td>方法区</td>
</tr>
<tr>
<td>常量类数据</td>
<td>String a= “abc”;</td>
<td>常量池是在方法区中的</td>
</tr>
<tr>
<td>new出来的对象</td>
<td>String a = new String(“123”);</td>
<td>new出来的对象放在堆区，而指向这块堆内存的引用a在栈区</td>
</tr>
</tbody></table>
<br>

<h3 id="分代管理与垃圾回收流程"><a href="#分代管理与垃圾回收流程" class="headerlink" title="分代管理与垃圾回收流程"></a>分代管理与垃圾回收流程</h3><p>虚拟机的堆内存可以再划分为“年轻代”、“年老代”和“持久代“三个区域</p>
<p><img src="https://s1.ax1x.com/2020/08/19/dlyjXD.png" alt="堆内存中分代管理的示意图" title="堆内存中分代管理的示意图"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，持久代（也叫持久区）中主要存放的是Java类信息或在代码里通过import引入的类信息，这块空间里的内存对象在代码运行时一般会持久地存在（也是被称为持久代的原因），所以我们平时讨论的垃圾回收流程一般不会涉及到这块空间。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在年轻区里，一般会划分为伊甸区和两个Survivor区（本书翻译成缓冲区，或许在其它资料上有其它的译法），而这里我们把Tenured翻译成年老代。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来我们来看下垃圾回收的一般流程。</p>
<ol>
<li>我们new出来的对象一般是先到伊甸区（Eden）里申请空间，如果伊甸区满了（当前从伊甸区里无法申请到空间），那么会把伊甸区里还存活的对象复制到其中的一个Survivor区里。这里其实已经有个隐含的回收流程，当我们把伊甸区存活的对象复制到Survivor区时，已经把其中无用的对象回收了。</li>
<li>接下来当伊甸区和其中的一个Survivor区都满了时，那么会把伊甸区和其中一个Survivor里的存活对象再复制到另外个Survivor区里，这里同样隐含着一次回收流程。</li>
<li>如果年轻代的空间都满了（即无法从伊甸区和两个Survivor区里申请到对象），那么虚拟机会把年轻代里还存活的对象复制到年老代里。</li>
<li>当年老代再满时（不会再复制到持久代了），会启动Full GC，对年轻代，年老代和持久代进行全面地回收了，这个就需要耗费较长的时间了。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上述的回收流程中，其实包含着两类回收机制。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一类是轻量级回收（Minor GC）。在年轻代里的回收流程都是属于这种，比如我们new出来的一个对象在Eden区申请空间失败，就会触发这类GC。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二类是刚才已经提到的重量级的Full GC流程，如下的四种情况会触发这种GC。</p>
<ol>
<li>年老代（Tenured）被写满。</li>
<li>持久代被写满。</li>
<li>程序员显式地调用了System.gc()方法。</li>
<li>我们可以通过java命令分配堆空间的运行策略，比如可以设置年轻代和年老代的比例，如果虚拟机监控到上次GC后，这种运行策略发生变化，也会触发Full GC。</li>
</ol>
<p>这里讲一个可能会导致误解的知识点，程序员还是可以通过System.gc()来建议虚拟机启动垃圾回收，但调用这个方法后，虚拟机一般并不会直接启动，而是会过会找个合适的时间点。这和我们之间给出的“程序员无法通过代码回收内存”说辞并不矛盾。</p>
<h3 id="判断对象可回收的依据"><a href="#判断对象可回收的依据" class="headerlink" title="判断对象可回收的依据"></a>判断对象可回收的依据</h3><ul>
<li>Java虚拟机如何判断一个对象可以被回收？标准非常简单，当某个对象上<u><strong>没有强引用</strong></u>时，该对象就可以被回收。</li>
<li>不过，在绝大多数的场景里，当某对象上的最后一个强引用被撤去后，该对象不会被立即回收，而是会在下次启动垃圾回收机制时被回收。</li>
<li>在JDK的早期版本里，是用“引用计数法”来判断对象上是否有强引用。在后继的JDK版本里，引入了<u><strong>“根搜索算法”(Tracing Collector)</strong></u>。</li>
</ul>
<h3 id="深入了解finalize方法"><a href="#深入了解finalize方法" class="headerlink" title="深入了解finalize方法"></a>深入了解finalize方法</h3><p>finalize()是Object类里的protected类型的方法，子类（所有类都是Object的子类）可以通过覆盖这个方法来实现回收前的资源清理工作。和这个方法相关的流程如下所述。</p>
<ol>
<li>Java虚拟机一旦通过刚才提到的“根搜索算法”判断出某对象处于可回收状态时，会判断该对象是否重写了Object类的finalize方法，如果没，则直接回收。</li>
<li>如重写过finalize方法，而且未执行过该方法，则把该对象其放入F-Queue队列，另个线程会定时遍历F-Queue队列，并执行该队列中各对象的finalize方法。</li>
<li>finalize方法执行完毕后，GC会再次判断该对象是否可被回收，如果可以，则进行回收，如果此时该对象上有强引用，则该对象“复活”，即处于“不可回收状态”。</li>
</ol>
<p>不过，由于垃圾回收和遍历F-Queue队列不是同一个线程，所以一旦重写了这个方法，就有可能导致对象被延迟回收，如果这个方法再被放入错误的代码，就极有可能导致该对象无法回收。所以一般不会重写finalize方法。</p>
<h3 id="强弱软虚四种引用"><a href="#强弱软虚四种引用" class="headerlink" title="强弱软虚四种引用"></a>强弱软虚四种引用</h3><p>在Java对象里，有<strong>强弱软虚</strong>四种引用，它们都和垃圾回收流程密切相关，在项目里，我们可以通过合理地使用不同类型的引用来优化代码的内存使用性能。</p>
<ul>
<li>强引用：<br>指向通过new得到的内存空间的引用叫强引用。比如有String a = newString(“123”);，其中的a就是一个强引用，它指向了一块内容是123的堆空间。</li>
<li>软引用（SoftReference）：<br>如果一个对象只具有软引用，而当前虚拟机堆内存空间足够，那么垃圾回收器就不会回收它，反之就会回收这些软引用指向的对象。</li>
<li>弱引用（WeakReference）：<br>垃圾回收器一旦发现某块内存上<u>只有弱引用</u>（一定请注意只有弱引用，没强引用），不管当前内存空间是否足够，那么都会回收这块内存。</li>
<li>虚引用</li>
</ul>
<h3 id="更高效地使用内存"><a href="#更高效地使用内存" class="headerlink" title="更高效地使用内存"></a>更高效地使用内存</h3><ol>
<li>物理对象（比如Connection或IO等对象）在用好后应当立即释放。<br>一般我们会用try…catch…finally的样式来使用Connection或IO等对象，那么我们就可以在finally从句里关闭这些对象。</li>
<li>当使用完某个对象时，应及时把它设置成null，比如obj = null;，这样就能撤销掉该引用对象上的强引用，从而能提升该对象的回收时间。</li>
<li>不应当频繁地操作String对象。<br>String属于不可变类，频繁地操作String会产生大量的内存碎片，从而加重内存的负担，尤其地，不建议在循环里操作String对象。在for循环里，我们频繁地进行了字符串连接操作，所以会频繁地开辟新的内存空间存放新值，旧的空间随之会废弃，这样会造成大量的内存损耗。在其它可能频繁操作String对象的场合里，也会导致大量产生内存碎片，遇到这种情况，我们可以用StringBuilder替代String。</li>
<li>集合对象在用好后，应当及时clear掉。</li>
<li>我们知道，如果能合理地使用弱引用和软引用，能减少对象上的强引用个数，从而能让该对象被回收的时间提前。所以，可以在一切必要的场合尽可能多地使用弱引用和软引用</li>
</ol>
<h3 id="HashMap底层数据结构"><a href="#HashMap底层数据结构" class="headerlink" title="HashMap底层数据结构"></a>HashMap底层数据结构</h3><p><strong>数组+链表+红黑树</strong></p>
<ul>
<li>当链表过长时，转为红黑树</li>
</ul>
<h3 id="HashMap、LinkedHashMap、TreeMap的比较"><a href="#HashMap、LinkedHashMap、TreeMap的比较" class="headerlink" title="HashMap、LinkedHashMap、TreeMap的比较"></a>HashMap、LinkedHashMap、TreeMap的比较</h3><ul>
<li>HashMap ： 根据Hash函数确认元素的存储顺序，添加了新的元素，之前的顺序可能完全逆转。</li>
<li>LinkedHashMap : 保持元素的插入顺序。</li>
<li>TreeMap : 保持 key 的自然顺序（根据 compareTo() 方法）。</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/08/28/dIFIGF.png" alt="dIFIGF.png"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>周末培训（二）</title>
    <url>/EchoNotes/2020/08/16/life2/</url>
    <content><![CDATA[<p>2020年8月16号周日，公司组织第二次培训</p>
<a id="more"></a>

<h2 id="第二次培训"><a href="#第二次培训" class="headerlink" title="第二次培训"></a>第二次培训</h2><h3 id="考试题"><a href="#考试题" class="headerlink" title="考试题"></a>考试题</h3><ol>
<li>写出如下代码的结果，同时说明理由。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String a &#x3D; &quot;abc&quot;;</span><br><span class="line">String b &#x3D; &quot;abc&quot;;</span><br><span class="line">System.out.println(a&#x3D;&#x3D;b);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>如何定义一个不可变类？</p>
</li>
<li><p>StringBuilder 和 StringBuffer 有什么区别？它们各自适用于哪些场合？</p>
</li>
<li><p>hashcode方法在哪些场景里需要重写？</p>
</li>
<li><p>抽象类和接口有什么区别？它们各自适用于哪些场合？</p>
</li>
<li><p>简述 Hash 表为什么能比较高效地定位到元素。</p>
</li>
<li><p>Java里的HashMap是怎么处理Hash定位冲突的？</p>
</li>
<li><p>根据场景回答问题。<br><strong>第一步</strong>，我们定义一个 Car 类，其中只有一个 int 类型的 id 属性。<br><strong>第二步</strong>，创建一个 Car 类的实例，假设是 C，设置它的 id 是 1。<br><strong>第三步</strong>，我们通过 new 关键字创建两个不同的 ArrayList，分别是 a1 和 a2，并把第二步里创建的c对象分别放入 a1 和 a2。<br><strong>第四步</strong>，我们在 a1 这个 ArrayList 里，拿出 c 对象，并把它的 id 设置成 2，同时不对存放在 a2 里的 c 对象做任何修改。<br>完成上述四步后，a2 里存放的 c 对象的 id 是多少？<br>同时说明理由。</p>
</li>
<li><p>说明 Java 虚拟机为什么能实现跨平台。</p>
</li>
<li><p>软引用和弱引用有什么差别？写出软引用和弱引用的一个适用场景。</p>
</li>
<li><p>finalize 和 final 关键字各有什么作用？</p>
</li>
<li><p>写出至少3种优化 Java 内存性能的编码规范。</p>
</li>
</ol>
<hr>
<h3 id="参考解答"><a href="#参考解答" class="headerlink" title="参考解答"></a>参考解答</h3><ol start="2">
<li><p>要创建不可变类，要实现下面几个步骤 ： <a href="https://www.cnblogs.com/acode/articles/7090429.html">链接</a></p>
<ol>
<li>将类声明为 final，所以它不能被继承</li>
<li>将所有的成员声明为私有的，这样就不允许直接访问这些成员</li>
<li>对变量不要提供 setter 方法</li>
<li>将所有可变的成员声明为 final，这样只能对它们赋值一次</li>
<li>通过构造器初始化所有成员，进行深拷贝(deep copy)</li>
<li>在 getter 方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝</li>
</ol>
</li>
<li><p>StringBuilder ： 线程不安全<br>StringBuffer ： 线程安全</p>
</li>
<li><p>在HashMap的“键”部分存放自定义对象的时候，一定要在这个对象里用自己的equals和hashCode方法来覆盖Object里的同名方法。</p>
</li>
<li><p>在Hash表里，存放在其中的数据和它的存储位置是用Hash函数关联的</p>
<p><img src="https://s1.ax1x.com/2020/08/18/duj6ns.png" alt="Hash表里存储数据的示意图" title="Hash表里存储数据的示意图"><br>这样做的好处非常明显。比如我们要从中找6这个元素，我们可以先通过Hash函数计算6的索引位置，然后直接从1号索引里找到它了。</p>
</li>
<li><p>假如经过Hash函数计算后，7和8有相同的Hash值，会遇到“Hash值冲突”这个问题，对此Java的HashMap对象采用的是“链地址法”的解决方案。<br><img src="https://s1.ax1x.com/2020/08/18/dujsXj.png" alt="Hash表用链地址法解决冲突的示意图" title="Hash表用链地址法解决冲突的示意图"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>周末培训（一）</title>
    <url>/EchoNotes/2020/08/09/life1/</url>
    <content><![CDATA[<p>2020年8月9号周日，公司组织第一次培训</p>
<a id="more"></a>

<h2 id="第一次培训"><a href="#第一次培训" class="headerlink" title="第一次培训"></a>第一次培训</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    需要监控的可能会抛出异常的代码块</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)&#123;</span><br><span class="line">    出现异常后的处理代码</span><br><span class="line">&#125;</span><br><span class="line">finally&#123;</span><br><span class="line">    回收资源的动作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>finally{} 里放内存回收相关的代码</p>
</li>
<li><p>在子类方法里不该抛出比父类范围更广的异常</p>
</li>
<li><p>try{} 里面包含可能抛出异常的代码,尽量减少用try监控的代码块</p>
</li>
<li><p>catch(){} 用专业的异常来处理，最后再用Exception异常来兜底</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    IO代码</span><br><span class="line">    数据库连接代码</span><br><span class="line">&#125;</span><br><span class="line">catch(IOException ioe)&#123;处理IO异常的代码&#125;</span><br><span class="line">catch(SQLException ioe)&#123;处理数据库操作异常的代码&#125;、</span><br><span class="line">catch(Exception ioe)&#123;最后再用Exception这个异常基类&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在catch从句里，别简单地抛出异常了事，应当尽可能地处理异常。</p>
</li>
</ol>
<h3 id="看慢SQL"><a href="#看慢SQL" class="headerlink" title="看慢SQL"></a>看慢SQL</h3><ol>
<li>Linux命令，MySql命令，看long SQL</li>
<li>监控CAT，Zabbix</li>
</ol>
<h3 id="数据库调优"><a href="#数据库调优" class="headerlink" title="数据库调优"></a>数据库调优</h3><ol>
<li>索引</li>
<li>缓存，redis</li>
<li>MySql集群，主从，读写分离，LVS，负载均衡</li>
<li>MyCAT分库分表</li>
</ol>
<h3 id="JDBC连接数据库"><a href="#JDBC连接数据库" class="headerlink" title="JDBC连接数据库"></a>JDBC连接数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JDBCRead &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 加载数据库驱动</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(&quot;加载数据库驱动失败&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Connection connection &#x3D; null;</span><br><span class="line">        Statement stmt &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建连接</span><br><span class="line">            connection &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;,&quot;root&quot;,&quot;123456&quot;);</span><br><span class="line">            if (connection !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; 通过Statement对象执行select语句</span><br><span class="line">                stmt &#x3D; connection.createStatement();</span><br><span class="line">                String query &#x3D; &quot;select id, username, password from t_user&quot;;</span><br><span class="line">                &#x2F;&#x2F; 通过ResultSet对象得到查询的结果</span><br><span class="line">                ResultSet rs &#x3D; stmt.executeQuery(query);</span><br><span class="line">                &#x2F;&#x2F; 通过rs.next()方法遍历查询结果</span><br><span class="line">                while (rs.next()) &#123;</span><br><span class="line">                    System.out.println(&quot;id &#x3D; &quot; + rs.getInt(&quot;id&quot;));</span><br><span class="line">                    System.out.println(&quot;username &#x3D; &quot; + rs.getString(&quot;username&quot;));</span><br><span class="line">                    System.out.println(&quot;password &#x3D; &quot; + rs.getString(&quot;password&quot;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;连接数据库失败&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            System.out.println(&quot;数据库连接抛出异常&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;数据库连接关闭&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取-properties文件"><a href="#读取-properties文件" class="headerlink" title="读取 .properties文件"></a>读取 .properties文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PropertiesRead &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String fileName;</span><br><span class="line">        if (args !&#x3D; null || args.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            fileName &#x3D; args[0] + &quot;.properties&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fileName &#x3D; &quot;sql.properties&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String driver &#x3D; null;</span><br><span class="line">        String url &#x3D; null;</span><br><span class="line">        String username &#x3D; null;</span><br><span class="line">        String password &#x3D; null;</span><br><span class="line">        Properties prop &#x3D; new Properties();</span><br><span class="line">        InputStream in &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 读取配置文件</span><br><span class="line">            URL url1 &#x3D; PropertiesRead.class.getClassLoader().getResource(fileName);</span><br><span class="line">            String path &#x3D; url1.getFile();</span><br><span class="line">            in &#x3D; new BufferedInputStream(new FileInputStream(path));</span><br><span class="line">            prop.load(in);</span><br><span class="line">            &#x2F;&#x2F; 读JDBC连接参数</span><br><span class="line">            driver &#x3D; prop.getProperty(&quot;mysql.Driver&quot;);</span><br><span class="line">            url &#x3D; prop.getProperty(&quot;mysql.url&quot;);</span><br><span class="line">            username &#x3D; prop.getProperty(&quot;mysql.username&quot;);</span><br><span class="line">            password &#x3D; prop.getProperty(&quot;mysql.pwd&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (in !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            prop.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;driver : &quot;+driver);</span><br><span class="line">        System.out.println(&quot;url : &quot;+url);</span><br><span class="line">        System.out.println(&quot;username : &quot;+username);</span><br><span class="line">        System.out.println(&quot;password : &quot;+password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚拟机体系结构和Java跨平台特性"><a href="#虚拟机体系结构和Java跨平台特性" class="headerlink" title="虚拟机体系结构和Java跨平台特性"></a>虚拟机体系结构和Java跨平台特性</h3>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>HexoNotes</title>
    <url>/EchoNotes/2020/08/07/HexoNotes/</url>
    <content><![CDATA[<p>Hexo：一个快速、简洁且高效的博客框架，Hexo 使用 Markdown（或其他渲染引擎）解析文章，生成静态网页。</p>
<a id="more"></a>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>清除缓存文件 (db.json) 和已生成的静态文件 (public)：<br><code>hexo clean</code></li>
<li>生成静态文件<br><code>hexo g</code></li>
<li>本地启动服务<br><code>hexo s</code></li>
<li>部署代码到远程仓库<br><code>hexo d</code></li>
</ul>
<h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><ul>
<li>创建新文章或者新的页面<br><code>hexo new [layout] &lt;title&gt;</code><br>Hexo有三种布局：post、page 和 draft</li>
</ul>
<h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><ul>
<li>文件最上方以 — 分隔的区域，用于指定个别文件的变量</li>
<li>参数：<ul>
<li>layout, title, date, updated, comments, tags, categories, permalink</li>
<li>例如:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"> - Diary</span><br><span class="line">tags:</span><br><span class="line"> - PS3</span><br><span class="line"> - Games</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Delphi 笔记</title>
    <url>/EchoNotes/2020/08/01/DelphiNotes/</url>
    <content><![CDATA[<p>Delphi是一门编程语言…</p>
<a id="more"></a>

<ul>
<li><p>AssignFile(F, ‘C:\MyFile.txt’)</p>
<ul>
<li>将C:\MyFile.txt文件与F变量建立连接，后面可以使用答F变量对文件进行操作。</li>
</ul>
</li>
<li><p>Rewrite（）</p>
<ul>
<li>创建不存在的文件但不包括文件夹</li>
</ul>
</li>
<li><p>ReadSections</p>
<ul>
<li>读取ini文件里面[]的值</li>
</ul>
</li>
<li><p>ReadSectionValues</p>
<ul>
<li>读取ini文件[]下面的key-value值</li>
</ul>
</li>
<li><p>readstring(“小节名”,”关键字”,缺省值)</p>
<ul>
<li>指定读取ini文件[]下面key对应的value值</li>
</ul>
</li>
<li><p>EOF</p>
<ul>
<li>是一个计算机术语，为End Of File的缩写，在操作系统中表示资料源无更多的资料可读取</li>
</ul>
</li>
<li><p>ShowWindowAsync</p>
<ul>
<li>一种函数，功能是该函数设置由不同线程产生的窗口的显示状态。</li>
</ul>
</li>
<li><p>ComponentCount</p>
<ul>
<li>指打开的窗体所拥有的控件个数，包含所有子组件、孙组件(子组件内的子组件)</li>
</ul>
</li>
<li><p>interval</p>
<ul>
<li>单位是0.001秒.如果该属性设置为1000,就是每隔一秒执行下OnTimer程序</li>
</ul>
</li>
<li><p>SetWindowLong  是一个WindowsAPI函数。该函数用来改变指定窗口的属性．函数也将指定的一个32位值设置在窗口的额外存储空间的指定偏移位置。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数原型：</span><br><span class="line">LONG SetWindowLong(</span><br><span class="line">    HWND hWnd,               &#x2F;&#x2F; handle to window</span><br><span class="line">    int nlndex,              &#x2F;&#x2F; offset of value to set</span><br><span class="line">    LONG dwNewLong           &#x2F;&#x2F; new value</span><br><span class="line">);</span><br><span class="line">如果函数成功，返回值是指定的32位整数的原来的值。如果函数失败，返回值为0。若想获得更多错误信息，请调用GetLastError函数。</span><br></pre></td></tr></table></figure></li>
<li><p>患者表：HOKUDAI1.B_PATIENT_INFO</p>
</li>
<li><p>Imemode属性：</p>
<ul>
<li>imClose 表示输入法处于关闭状态；</li>
<li>ImOpen 表示输入法处于打开状态；</li>
<li>ImChinese 表示处于中文输入法状态；</li>
<li>ImDontCare 表示若输入法处于关闭状态则打开最近一次使用过的输入法；</li>
<li>ImSAlpha 表示输入处于半角状态；</li>
<li>ImAlpha 表示输入处于全角状态。</li>
</ul>
</li>
<li><p>OnNeedData:</p>
<ul>
<li>这个事件本身是一个循环，循环起点是把MoreData置为真 “MoreData:=True;”<br>紧接着要注意加入判定是否结束语句<br>如：if QRDBText1.Dataset.Eof then MoreData:=False;<br>如果判断语句放在事件最后，将导致QRDBText1.Dataset的最后一条记录不会被打印。<br>该事件非常适合用于在追加数据集时根据数据集的内容设置字体等</li>
</ul>
</li>
<li><p>FindFirst：</p>
<ul>
<li>是用来寻找目标目录下的第一个文件，当成功找到文件时,返回0.</li>
</ul>
</li>
<li><p>FindNext：</p>
<ul>
<li>则是寻找下一个</li>
</ul>
</li>
<li><p>Rewrite(&lt;文件变量名&gt;)：</p>
<ul>
<li>若无该文件，则创建文件。<br>若有该文件，覆盖掉原文件。<br>打开文件后，可以对文件内容进行写操作。</li>
</ul>
</li>
<li><p>Append(&lt;文件变量名&gt;)：</p>
<ul>
<li>追加内容到文件中。文件必须要存在。</li>
</ul>
</li>
<li><p>application.ProcessMessages:</p>
<ul>
<li>主要作用使程序在循环时能够响应外界事件。一般情况下，程序在循环的时候不响应外界事件。直到循环结束为止才能接受和响应外界事件。application.ProcessMessages可以有效的解决循环循环的独占问题，能够暂时中断应用程序的执行</li>
</ul>
</li>
<li><p>IncludeTrailingPathDelimiter(const S:String):String</p>
<ul>
<li>和IncludeTrailingBackslash是同样功能，不过根据delphi的帮助，我们现在应该使用IncludeTrailingPathDelimiter才对，前者只是为了向前兼容才保留的,这个函数是将参数S提供的一个表示路径的末尾加上“/”符（如果是unix系统，则加上“/”）</li>
</ul>
</li>
<li><p>ExcludeTrailingPathDelimiter(const S:String):String</p>
<ul>
<li>和ExcludeTrailingBackslash是同样功能，同样我们应该使用ExcludeTrailingPathDelimiter<br>这个函数和IncludeTrailingPathDelimiter正好相反，是用来去掉一个路径末尾的斜杠符的</li>
</ul>
</li>
<li><p>拷贝参考的文件后，需要提交一次原始的代码，注释是copy…</p>
</li>
<li><p>打印：</p>
<ul>
<li>先安装驱动（LBP3018_R150_V110_W32_ZH_1.exe这个EXE解压后里面有setup），再连接打印机地址 双击连接打印机地址时出来的打印机图标</li>
<li>打印机地址 192.168.15.125</li>
<li>user:administrator</li>
<li>password:newtouch@1234125</li>
</ul>
</li>
<li><p>表：</p>
<ul>
<li>I_Results_view 检查结果登录表</li>
<li>D_RECORD 透析记录表</li>
<li>B_PATIENT_INFO 患者信息表</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>delphi</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 笔记</title>
    <url>/EchoNotes/2020/07/28/VueNotes/</url>
    <content><![CDATA[<p>Vue是近年很流行的前端开发框架…</p>
<a id="more"></a>

<h4 id="指令"><a href="#指令" class="headerlink" title="指令:"></a>指令:</h4><ul>
<li>指令带有前缀v-,职责是当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li>
<li>v-bind: 绑定数据和元素的属性,例如 <code>v-bind:title=&quot;&quot;</code>, <code>v-bind:class=&quot;&quot;（class和style的绑定）</code>，缩写为 <code>:title=&quot;&quot;</code>, <code>:class=&quot;&quot;</code></li>
<li>条件与循环： v-if 和 v-for</li>
<li>事件监听： v-on，例如 v-on:click=””，缩写为 @click=””</li>
<li>双向绑定： v-model，例如 v-model=””</li>
<li>条件渲染： v-if, v-else-if, v-else, v-show</li>
<li>v-else-if 和 v-else 必须紧跟在 v-if 或者 v-else-if 后面。否则它将不会被识别</li>
<li>不推荐同时使用 v-if 和 v-for,当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级.</li>
<li>v-if 和 v-show 的比较：<ul>
<li>v-show 不支持 &lt;template&gt; 元素，也不支持 v-else。<ul>
<li>v-if 是“真正”的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。如果在初始渲染时条件为假，则什么也不做,——直到条件第一次变为真时，才会开始渲染条件块</li>
<li>v-show不管初始条件是什么，元素总是会被渲染，并且只是基于 CSS 进行切换,切换元素的 CSS property display，元素始终会被渲染并保留在 DOM 中</li>
<li>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好.</li>
</ul>
</li>
</ul>
</li>
<li>用key管理可复用的元素： Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。如果不需要复用，只需要在元素上添加一个具有唯一值的 key attribute 即可。请用字符串或数值类型的值作为key</li>
<li>列表渲染： v-for，语法格式 item in items，也可以用 of 代替 in 作为分隔符，items是源数据，item是被迭代的元素的别名。建议尽可能在使用 v-for 时提供 key attribute<ul>
<li>遍历数组: v-for=”(item, index) in items”， item: property， index: 当前项的索引</li>
<li>遍历对象: v-for=”(value,name,index) in object”, value: property, name: property名称(键名), index: 索引</li>
</ul>
</li>
<li>事件修饰符： Vue.js 为 v-on 提供了事件修饰符，修饰符是由点开头的指令后缀来表示的。修饰符可以串联，使用时顺序很重要<ul>
<li>.stop</li>
<li>.prevent</li>
<li>.capture</li>
<li>.self</li>
<li>.once</li>
<li>.passive</li>
</ul>
</li>
<li>按键修饰符： 监听键盘事件，v-on:keyup.page-down=” “， @keyup.enter=” “ （可能需要加上 .native）</li>
<li>.exact修饰符： 控制精确的系统修饰符组合触发的事件。</li>
<li>鼠标按钮修饰符： @click.left=””， @click.right=””， @click.middle=””</li>
<li>表单输入绑定修饰符：<ul>
<li>v-model.lazy=””，在默认情况下，v-model在每次input事件触发后将输入框的值与数据进行同步，这时可以添加lazy修饰符，从而转为在change事件之后进行同步</li>
<li>v-model.number=””，自动将用户的输入值转为数值类型</li>
<li>v-model.trim=””，自动过滤用户输入的首尾空白字符</li>
</ul>
</li>
<li>Vue暴露出了一些有用的实例property和方法，它们都有前缀$，以便与用户定义的property区分开。 例如： vm.$data, vm.$watch()</li>
<li>计算属性：computed，计算属性是基于它们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时它们才会重新求值,大多数情况下更合适</li>
<li>侦听属性：watch，当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的</li>
<li><strong>在 JavaScript中，truthy（真值）指的是在布尔值上下文中，转换后的值为真的值。所有值都是真值，除非它们被定义为 假值（即除 false、0、””、null、undefined 和 NaN 以外皆为真值）。JavaScript 在布尔值上下文中使用强制类型转换（coercion）。</strong></li>
<li>ref：<ul>
<li>用来给DOM元素或子组件注册引用信息。引用信息会根据父组件的 $refs 对象进行注册。如果在普通的DOM元素上使用，引用信息就是元素; 如果用在子组件上，引用信息就是组件实例</li>
<li>只要想要在Vue中直接操作DOM元素，就必须用ref属性进行注册</li>
<li>例如要在create的时候引用DOM元素，先在DOM中使用ref标签进行注册，然后便可以通过’this.$refs’再跟注册时的名称来引用DOM元素了</li>
</ul>
</li>
</ul>
<hr>
<h4 id="组件基础："><a href="#组件基础：" class="headerlink" title="组件基础："></a>组件基础：</h4><ul>
<li>组件是可复用的Vue实例，并且带有一个名字</li>
<li>组件的data选项必须是一个函数，不能直接提供一个对象</li>
<li>自定义的组件必须先注册，Vue才能够识别并在模板中使用，组件的注册方式有<strong>全局注册</strong>和<strong>局部注册</strong></li>
<li>通过prop向子组件传递数据</li>
<li>监听子组件事件<ul>
<li>父级组件可以像处理 native DOM 事件一样通过 v-on 监听子组件实例的任意事件</li>
<li>子组件可以通过调用 $emit 方法并传入事件名称来触发一个事件</li>
</ul>
</li>
<li>子组件使用事件抛出一个值<ul>
<li>子组件使用 $emit 方法的第二个参数来提供这个值</li>
<li>在父级组件监听这个事件的时候，可以：<ul>
<li>通过 $event 直接访问到被抛出的这个值</li>
<li>或者，如果父级组件对这个事件的处理函数是一个方法，那么这个值将会作为第一个参数传入这个方法</li>
</ul>
</li>
</ul>
</li>
<li>通过插槽分发内容：&lt;slot&gt;</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 笔记</title>
    <url>/EchoNotes/2020/07/20/MarkdownNotes/</url>
    <content><![CDATA[<p>摘要…</p>
<a id="more"></a>

<h4 id="Markdown是一种纯文本格式的标记语言"><a href="#Markdown是一种纯文本格式的标记语言" class="headerlink" title="Markdown是一种纯文本格式的标记语言"></a>Markdown是一种纯文本格式的标记语言</h4><ul>
<li><p>标题：在文字前加 # 和一个空格来表示，一个 # 是一级标题，两个 # 是两级标题，以此类推，最高可支持六级标题</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">...</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure></li>
<li><p>字体</p>
<ul>
<li><strong>加粗</strong>：要加粗的文字左右分别用两个*号包起来，<code>**文字**</code></li>
<li><em>倾斜</em>：要倾斜的文字左右分别用一个*号包起来，<code>*文字*</code></li>
<li><strong><em>斜体加粗</em></strong>：要倾斜和加粗的文字左右分别用三个*号包起来，<code>***文字***</code></li>
<li><del>删除线</del>：要加删除线的文字左右分别用两个<del>号包起来，`</del>文字~~`</li>
<li><u>下划线</u>：下划线可以通过 HTML 的 &lt;u&gt; 标签来实现，<code>&lt;u&gt;文字&lt;/u&gt;</code></li>
</ul>
</li>
<li><p>换行：段落的换行是使用两个以上空格加上回车，或者在段落后面使用一个空行来表示重新开始一个段落。</p>
</li>
<li><p>引用：在引用的文字前加 &gt; 即可，引用也可以嵌套，如加两个&gt;&gt;，三个&gt;&gt;&gt;，n个&gt;…</p>
</li>
<li><p>分割线：三个或者三个以上的 - 或者 * 都可以，<code>---</code>，<code>***</code></p>
</li>
</ul>
<hr>
<hr>
<ul>
<li><p>图片：</p>
<p>  <img src="https://cn.vuejs.org/images/logo.png" alt="Vue Logo" title="Vue是近年来很受欢迎的前端开发框架"></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法： ![图片名](图片地址 &quot;图片title&quot;)</span><br><span class="line">    图片名就是显示在图片下面的文字</span><br><span class="line">    图片title是图片的标题，当鼠标移到图片上时显示的内容，title可加可不加</span><br></pre></td></tr></table></figure>
<ul>
<li>超链接：<a href="https://cn.vuejs.org/v2/guide/" title="Vue官方出版的多国语言教程">Vue官方教程</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">      title可加可不加</span><br></pre></td></tr></table></figure></li>
<li>列表：<ul>
<li>无序列表：无序列表用 - + * 任何一种加上空格都可以  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   - 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line">注意：- + * 与内容之间有一个空格</span><br></pre></td></tr></table></figure></li>
<li>有序列表：数字加点加空格  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line">注意：点跟内容之间有一个空格</span><br></pre></td></tr></table></figure></li>
<li>列表嵌套：上一级列表和下一级列表之间敲三个空格即可</li>
</ul>
</li>
<li>表格：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|表头|表头|表头|</span><br><span class="line">|---|:--:|---:|</span><br><span class="line">|内容|内容|内容|</span><br><span class="line">|内容|内容|内容|</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br></pre></td></tr></table></figure></li>
<li>代码<ul>
<li>单行代码：代码两边分别用一个反引号 ` 包起来，<code>代码内容</code></li>
<li>代码块：代码两边分别用三个反引号包起来，且两边的反引号单独占一行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">代码...</span><br><span class="line">代码...</span><br><span class="line">代码...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>流程图</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
